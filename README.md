# firely

Firely is an A/B Testing overlay based on Firebase Remote Config.
It's a work in progress to simplify the integration and make the management of A/B testing XPs safer. 

## How does it work

This library, integrated in your gradle project, only requires:
- A `firely-config.json` file that will contains the type of items, the keys, and the default value
- A call to `Firely.setup(Context context)` from the `Application.onCreate()` method
- One proguard rule

`firely-config.json` file is organized in 3 main sections (for us, but it can have the "names" you want):
- Feature Flags
- Config
- Experiments

Here is an example of `firely-config.json` (should be in the root directory of your project):
```json
{
  "config": [
    {
      "key": "android_version_code_min",
      "default": 0
    }
  ],
  "feature_flag": [
    {
      "key": "refer_a_friend",
      "default": true
    },
    {
      "key": "promotion_url",
      "default": ""
    }
  ],
  "experiment": [
    {
      "key": "xp_button_pay",
      "default": "control"
    }
  ]
}
```

Firely is an Android library that come with a gradle plugin, `firely-plugin`. It will generate a `FirelyConfig.java` file based on the `firely-config.json`, like the `R.java` of android does. The `FirelyConfig.java` will contain Enums that matches the configuration. You can then use these enums on Firely to get `LiveVariable`, `CodeBlock`, `OrderedArrayBlock`.


### LiveVariable

Let's imagine I am using Remote Config to restrict my user to an Android minimum version on which they can run (otherwise they have to update the app). With Firely, I can instantiate a LiveVariable that will point on this flag:

```java
LiveVariable<Integer> minAndroidRemoteVersion = Firely.integerVariable(FirelyConfig.Config.ANDROID_VERSION_CODE_MIN);
```

`FirelyConfig.Config.ANDROID_VERSION_CODE_MIN` is generated by the plugin and the default value is 0.

Now, anytime I need to get the last version that has been fetched, I just call:

```java
Integer lastVersion = minAndroidRemoteVersion.get();
```

Here is another example with a feature flag:

```java
if (Firely.booleanVariable(FirelyConfig.FeatureFlag.REFER_A_FRIEND).get()) {
	// Add the view
}
```


### CodeBlock

Now I need to do an XP that will change the text of a button.

```java
Firely.codeBlock(Remote.Experiment.XP_BUTTON)
	.withVariant("billed_currency", "no_price")
	.execute(
	() -> advance.setText(getString(R.string.bb_payment_cta)), // control
	() -> advance.setText(.getString(R.string.bb_payment_cta_2)), // billed_currency
	() -> advance.setText(getString(R.string.bb_payment_cta_3))); // no_price
```

Note here: we are always using "control" has the default and control for XPs.


### OrderedArrayBlock

At Busbud, we are using a lot of blocks and lists. Let's imagine you got n blocks of data in a page.
You want to A/B test which one should go first and in which order.
A basic approach could be to have n! variants.

If we have three items: 1-2-3, 2-1-3, 2-3-1, 1-3-2, 3-2-1, 3-1-2

And while using CodeBlocks:

```java
Firely.codeBlock(Remote.Experiment.XP_BUTTON)
	.withVariant("2-1-3", "2-3-1", "1-3-2", "3-2-1", "3-1-2")
	.execute(
	() -> {
		addOne();
		addTwo();
		addThree();
	}, // control
	() -> {
		addTwo();
		addOne();
		addThree();
	},
	... etc

```
Really inefficient.

Another approach is to use OrderArrayBlock. You will use one firebase entry:

```json
{
  ...
  "experiment": [
    {
      "key": "xp_mypage_order",
      "default": "one,two,three"
    }
  ]
}
```

```java
OrderedArrayBlock mCheckoutXp = 
		Firely.orderedArrayBlock(FirelyConfig.Experiment.XP_CHECKOUT_ORDER)
			.addStep("one", () -> addOne())
			.addStep("two", () -> addTwo())
			.addStep("three", () -> addThree());
```

And you can control your XPs from the Firebase Remote Config dashboard with changing the `xp_mypage_order` key.

`three,one,two` will them call `addThree()`, `addOne()`, `addTwo()`.

### Analytics

One of the hightlight of Firebase is that everything is working together. In the [documentation](https://firebase.google.com/docs/remote-config/config-analytics), Firebase propose to put the values, manually, as User Property:

```java
String experiment1_variant = FirebaseRemoteConfig.getInstance().getString("experiment1");
   AppMeasurement.getInstance(context).setUserProperty("MyExperiment",experiment1_variant);
```

Which is nice, but does not fit our needs. Putting the property at the user level will be erased with time and we will lose the informations. At Busbud, we prefer to tag all the events with all the experiments that have been applied at the time the event is triggered.

We added a method on Firely:

```java
Firely.getAllPropsWithCurrentValue()
```
And this method is called each time we are sending an event and merge to the property list. 
Therefore we can track the change of config in time.


## Use in the project


You need to apply the plugin (TODO integrate in maven repo):

```
buildscript {
    repositories {
        mavenLocal()
        jcenter()
    }

    dependencies {
        classpath group: 'com.busbud.android', name: 'firely-plugin', version: '0.1.0'
    }
}

apply plugin: 'com.busbud.android.firely'

```

You also need to import the aar (TODO integrate in maven repo):

`compile project(':firely-0.1.0')`


